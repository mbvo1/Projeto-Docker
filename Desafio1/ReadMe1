üê≥ Desafio 1: Containers em RedeüéØ ObjetivoO objetivo deste desafio √© implementar e demonstrar a comunica√ß√£o funcional entre dois containers Docker totalmente isolados (Cliente e Servidor), utilizando uma rede Docker customizada (bridge)1111.üí° Arquitetura e Solu√ß√£oA solu√ß√£o implementa uma arquitetura Cliente-Servidor simples, onde dois servi√ßos s√£o definidos em Dockerfiles separados e orquestrados manualmente em uma rede nomeada22.ComponenteTecnologiaPortaFun√ß√£oServidorPython + Flask8080Executa o servidor web (app.py) e retorna a identifica√ß√£o do container (hostname/ID)33.ClienteAlpine Linux + cURLN/ARealiza requisi√ß√µes HTTP peri√≥dicas (a cada 5 segundos) ao Servidor44.Decis√µes T√©cnicasSepara√ß√£o de Preocupa√ß√µes: Utilizamos Dockerfile.server e Dockerfile.client para isolar as depend√™ncias: o servidor precisa de Python/Flask, e o cliente precisa apenas de curl.Comunica√ß√£o por Nome: A chave da comunica√ß√£o √© o DNS interno do Docker55. O Cliente envia a requisi√ß√£o para o nome do servi√ßo (http://servidor:8080), e o Docker resolve esse nome para o IP do container Servidor dentro da rede customizada.‚öôÔ∏è Explica√ß√£o Detalhada do Funcionamento (Fluxo)In√≠cio do Servidor: O container Servidor √© iniciado na rede customizada com o alias de rede servidor. O Flask inicia o servidor web na porta interna 80806666.In√≠cio do Cliente: O container Cliente √© iniciado na mesma rede77. Seu comando (CMD) inicia um loop infinito que executa o curl a cada 5 segundos88.Resolu√ß√£o de Nome: A requisi√ß√£o do Cliente para http://servidor:8080 √© interceptada pelo DNS da rede customizada, que direciona o tr√°fego para o IP do container Servidor9999.Logs: O Servidor registra o acesso, e o Cliente exibe a resposta (Ol√° do container ID: ...) em seus logs, demonstrando que a troca de mensagens est√° funcionando10.üõ†Ô∏è Instru√ß√µes de Execu√ß√£o Passo a PassoSiga os passos abaixo para construir, configurar a rede e executar os containers.1. Constru√ß√£o das ImagensExecute os comandos abaixo na raiz da pasta Desafio1:Bash# 1. Constr√≥i a imagem do Servidor (usa Dockerfile.server)
docker build -t desafio1-server -f Dockerfile.server .

# 2. Constr√≥i a imagem do Cliente (usa Dockerfile.client)
docker build -t desafio1-client -f Dockerfile.client .
2. Cria√ß√£o da Rede CustomizadaCrie a rede Docker customizada, que √© obrigat√≥ria para a comunica√ß√£o por nome entre os servi√ßos1111:Bash# Cria uma nova rede chamada 'desafio1-network'
docker network create desafio1-network
3. Execu√ß√£o dos ContainersA. Iniciar o Container ServidorInicie o Servidor em modo detached (-d), conectando-o √† rede e definindo o alias de servi√ßo servidor. Este alias √© o nome que o Cliente usa no comando curl1212.Bashdocker run -d \
--name servidor-app \
--network desafio1-network \
--network-alias servidor \
desafio1-server
B. Iniciar o Container Cliente (e Monitorar)Inicie o Cliente, conectando-o √† mesma rede. Este container ser√° executado em foreground e come√ßar√° imediatamente a fazer requisi√ß√µes a cada 5 segundos13131313:Bash# O container do cliente far√° requisi√ß√µes a cada 5 segundos e exibir√° os logs.
docker run --rm \
--name cliente-app \
--network desafio1-network \
desafio1-client
4. Demonstra√ß√£o e Teste (Logs)O log do Cliente exibir√° mensagens como a seguir, comprovando que a comunica√ß√£o est√° funcional e que a rede customizada est√° operando corretamente14:Ola do container ID: <ID_ALEATORIO_DO_SERVIDOR>
--- Requisicao feita ---
Ola do container ID: <ID_ALEATORIO_DO_SERVIDOR>
--- Requisicao feita ---
...
5. Limpeza do AmbientePara finalizar e remover todos os recursos criados:Bash# 1. Parar os containers
docker stop servidor-app cliente-app

# 2. Remover os containers
docker rm servidor-app cliente-app

# 3. Remover a rede customizada
docker network rm desafio1-network
